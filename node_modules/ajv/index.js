const isObject = (value) => typeof value === 'object' && value !== null && !Array.isArray(value);

function normalizePath(path) {
  if (!path) {
    return '';
  }
  return path;
}

function pushError(errors, path, keyword, message) {
  errors.push({
    instancePath: normalizePath(path),
    schemaPath: '',
    keyword,
    message
  });
}

function matchesType(expectedType, value) {
  if (!expectedType) {
    return true;
  }

  const types = Array.isArray(expectedType) ? expectedType : [expectedType];

  for (const type of types) {
    switch (type) {
      case 'string':
        if (typeof value === 'string') {
          return true;
        }
        break;
      case 'number':
        if (typeof value === 'number' && Number.isFinite(value)) {
          return true;
        }
        break;
      case 'integer':
        if (Number.isInteger(value)) {
          return true;
        }
        break;
      case 'boolean':
        if (typeof value === 'boolean') {
          return true;
        }
        break;
      case 'object':
        if (isObject(value)) {
          return true;
        }
        break;
      case 'array':
        if (Array.isArray(value)) {
          return true;
        }
        break;
      case 'null':
        if (value === null) {
          return true;
        }
        break;
      default:
        break;
    }
  }

  return false;
}

function validate(schema, data, path, errors) {
  if (schema === true || schema === undefined) {
    return true;
  }

  if (schema === false) {
    pushError(errors, path, 'false schema', 'El esquema prohíbe este valor.');
    return false;
  }

  const typeMatches = matchesType(schema.type, data);
  if (!typeMatches) {
    pushError(errors, path, 'type', `El valor debe ser de tipo ${schema.type}.`);
    return false;
  }

  if (schema.enum && !schema.enum.includes(data)) {
    pushError(errors, path, 'enum', 'El valor no se encuentra en el conjunto permitido.');
  }

  if (schema.const !== undefined && schema.const !== data) {
    pushError(errors, path, 'const', 'El valor debe ser constante.');
  }

  if (typeof data === 'string') {
    if (schema.minLength !== undefined && data.length < schema.minLength) {
      pushError(errors, path, 'minLength', `La longitud mínima es ${schema.minLength}.`);
    }

    if (schema.maxLength !== undefined && data.length > schema.maxLength) {
      pushError(errors, path, 'maxLength', `La longitud máxima es ${schema.maxLength}.`);
    }

    if (schema.pattern) {
      const regex = new RegExp(schema.pattern);
      if (!regex.test(data)) {
        pushError(errors, path, 'pattern', 'El formato del texto no es válido.');
      }
    }
  }

  if (Array.isArray(data)) {
    if (schema.minItems !== undefined && data.length < schema.minItems) {
      pushError(errors, path, 'minItems', `Se requieren al menos ${schema.minItems} elementos.`);
    }

    if (schema.maxItems !== undefined && data.length > schema.maxItems) {
      pushError(errors, path, 'maxItems', `Se permiten como máximo ${schema.maxItems} elementos.`);
    }

    if (schema.items) {
      data.forEach((item, index) => {
        validate(schema.items, item, `${path}/${index}`, errors);
      });
    }
  }

  if (isObject(data)) {
    if (schema.required) {
      for (const property of schema.required) {
        if (!(property in data)) {
          pushError(errors, `${path}/${property}`, 'required', 'La propiedad es obligatoria.');
        }
      }
    }

    if (schema.properties) {
      for (const [property, propertySchema] of Object.entries(schema.properties)) {
        if (property in data) {
          validate(propertySchema, data[property], `${path}/${property}`, errors);
        }
      }
    }

    if (schema.additionalProperties === false && schema.properties) {
      for (const key of Object.keys(data)) {
        if (!(key in schema.properties)) {
          pushError(errors, `${path}/${key}`, 'additionalProperties', 'Propiedad no permitida.');
        }
      }
    }
  }

  return errors.length === 0;
}

export default class Ajv {
  constructor(options = {}) {
    this.options = options;
  }

  compile(schema) {
    const validator = (data) => {
      const errors = [];
      validate(schema, data, '', errors);
      validator.errors = errors.length ? errors : null;
      return errors.length === 0;
    };

    validator.errors = null;
    return validator;
  }
}
